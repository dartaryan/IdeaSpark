import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

interface GenerateRequest {
  prdId: string;
  ideaId: string;
  prdContent: {
    problemStatement: string;
    goals: string;
    userStories: string;
    requirements: string;
    technicalConsiderations: string;
  };
}

interface RefineRequest {
  prototypeId: string;
  refinementPrompt: string;
}

interface GenerateResponse {
  prototypeId: string;
  status: 'generating' | 'ready' | 'failed';
  url?: string;
  code?: string;
}

interface RefineResponse {
  newPrototypeId: string;
  status: 'generating' | 'ready' | 'failed';
  version: number;
}

interface RestoreRequest {
  restoreFromId: string;
}

interface RestoreResponse {
  id: string;
  version: number;
  status: 'ready';
  url: string | null;
  code: string | null;
}

interface ErrorResponse {
  error: string;
  code: string;
}

const OPEN_LOVABLE_API_URL = Deno.env.get('OPEN_LOVABLE_API_URL');
const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

const GENERATION_TIMEOUT_MS = 60000; // 60 seconds

/**
 * PassportCard theme configuration for prototype generation
 */
const PASSPORTCARD_THEME_PROMPT = `
Generate a React application with the exact PassportCard brand specifications:

BRAND IDENTITY:
- Primary color: #E10514 (PassportCard red)
- Secondary: #1a1a2e (dark navy)
- Background: #f8f9fa (light gray)
- Success: #10b981, Warning: #f59e0b, Error: #ef4444

TYPOGRAPHY:
- Headings: Montserrat, font-weight 600-700
- Body text: Rubik, font-weight 400
- Include Google Fonts import

STYLING:
- CSS Framework: Tailwind CSS with DaisyUI
- Border radius: 20px (rounded-box)
- Card padding: 24px
- Modern, professional appearance

RESPONSIVE:
- Mobile-first design
- Proper breakpoints (sm, md, lg)
- Touch-friendly interactions

OUTPUT:
- Complete, self-contained React component
- Inline styles or Tailwind classes
- No external dependencies except React
- Include all necessary imports
`;

/**
 * Retry wrapper with exponential backoff
 */
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      console.error(`Attempt ${attempt + 1} failed:`, error);

      if (attempt < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}

/**
 * Call Open-Lovable API with timeout
 */
async function generateWithOpenLovable(
  promptOrContent: string | GenerateRequest['prdContent'],
  options?: { isRefinement?: boolean }
): Promise<{ code: string; url: string }> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), GENERATION_TIMEOUT_MS);

  try {
    // Build prompt based on input type
    const prompt = typeof promptOrContent === 'string' 
      ? promptOrContent 
      : buildGenerationPrompt(promptOrContent);

    const response = await fetch(`${OPEN_LOVABLE_API_URL}/api/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${GEMINI_API_KEY}`, // Open-Lovable uses Gemini
      },
      body: JSON.stringify({
        prompt,
        config: {
          framework: 'react',
          styling: 'tailwindcss',
          includeTypes: true,
        },
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Open-Lovable API error:', response.status, errorText);
      throw new Error(`Open-Lovable API error: ${response.status}`);
    }

    const data = await response.json();

    if (!data.code) {
      throw new Error('No code generated by Open-Lovable');
    }

    return {
      code: data.code,
      url: data.url || null,
    };
  } catch (error) {
    clearTimeout(timeoutId);

    if (error.name === 'AbortError') {
      throw new Error('Prototype generation timed out after 60 seconds');
    }

    throw error;
  }
}

/**
 * Build generation prompt from PRD content
 */
function buildGenerationPrompt(prdContent: GenerateRequest['prdContent']): string {
  return `
${PASSPORTCARD_THEME_PROMPT}

Create a React prototype based on this Product Requirements Document:

## Problem Statement
${prdContent.problemStatement}

## Goals
${prdContent.goals}

## User Stories
${prdContent.userStories}

## Requirements
${prdContent.requirements}

## Technical Considerations
${prdContent.technicalConsiderations}

Generate a fully functional React prototype that:
1. Addresses the problem statement visually
2. Implements key user stories as interactive UI
3. Uses PassportCard branding throughout
4. Is responsive and professional
5. Includes realistic placeholder content

Return the complete React code ready to render.
`;
}

/**
 * Build refinement prompt with context
 */
function buildRefinementPrompt(
  prdContent: any,
  currentCode: string,
  refinementRequest: string
): string {
  return `
${PASSPORTCARD_THEME_PROMPT}

You are refining an existing React prototype. The user wants to make changes.

## Original PRD Context
${prdContent.problemStatement || prdContent.problem_statement || ''}
${prdContent.userStories || prdContent.user_stories || ''}

## Current Prototype Code
${currentCode}

## User's Refinement Request
${refinementRequest}

CRITICAL REQUIREMENTS:
1. Make ONLY the changes requested by the user
2. Maintain ALL PassportCard branding (#E10514 red, 20px radius, Montserrat/Rubik fonts)
3. Keep all existing functionality unless explicitly asked to change
4. Ensure the refined prototype is fully functional
5. Maintain responsive design

Generate the complete refined React code.
`;
}

/**
 * Handle version restoration
 * Creates a new version copying code/url from selected version
 */
async function handleRestoration(
  supabase: any,
  user: any,
  body: RestoreRequest
): Promise<Response> {
  // Get the prototype to restore from
  const { data: sourcePrototype, error: fetchError } = await supabase
    .from('prototypes')
    .select('*, prd_documents!inner(*)')
    .eq('id', body.restoreFromId)
    .eq('status', 'ready')  // Only restore from successful versions
    .single();

  if (fetchError || !sourcePrototype) {
    return new Response(
      JSON.stringify({ 
        error: 'Prototype version not found or not ready', 
        code: 'NOT_FOUND' 
      } as ErrorResponse),
      { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Verify ownership
  if (sourcePrototype.user_id !== user.id) {
    return new Response(
      JSON.stringify({ 
        error: 'Not authorized', 
        code: 'AUTH_ERROR' 
      } as ErrorResponse),
      { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Get current max version for this PRD
  const { data: maxVersionData } = await supabase
    .from('prototypes')
    .select('version')
    .eq('prd_id', sourcePrototype.prd_id)
    .order('version', { ascending: false })
    .limit(1)
    .single();

  const nextVersion = maxVersionData ? maxVersionData.version + 1 : 1;

  // Create new prototype version copying from source
  const { data: newPrototype, error: createError } = await supabase
    .from('prototypes')
    .insert({
      prd_id: sourcePrototype.prd_id,
      idea_id: sourcePrototype.idea_id,
      user_id: user.id,
      code: sourcePrototype.code,
      url: sourcePrototype.url,
      status: 'ready',
      version: nextVersion,
      refinement_prompt: `Restored from v${sourcePrototype.version}`,
    })
    .select()
    .single();

  if (createError) {
    console.error('Failed to create restored version:', createError);
    return new Response(
      JSON.stringify({ 
        error: 'Failed to create restored version', 
        code: 'DB_ERROR' 
      } as ErrorResponse),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  const response: RestoreResponse = {
    id: newPrototype.id,
    version: nextVersion,
    status: 'ready',
    url: newPrototype.url,
    code: newPrototype.code,
  };

  return new Response(
    JSON.stringify(response),
    { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
  );
}

/**
 * Handle refinement request
 */
async function handleRefinement(
  supabase: any,
  user: any,
  body: RefineRequest
): Promise<Response> {
  // Get current prototype with PRD content
  const { data: currentPrototype, error: fetchError } = await supabase
    .from('prototypes')
    .select('*, prd_documents!inner(content)')
    .eq('id', body.prototypeId)
    .single();

  if (fetchError || !currentPrototype) {
    return new Response(
      JSON.stringify({ 
        error: 'Prototype not found', 
        code: 'NOT_FOUND' 
      } as ErrorResponse),
      { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Verify ownership
  if (currentPrototype.user_id !== user.id) {
    return new Response(
      JSON.stringify({ 
        error: 'Not authorized', 
        code: 'AUTH_ERROR' 
      } as ErrorResponse),
      { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Get current max version for this PRD
  const { data: maxVersionData } = await supabase
    .from('prototypes')
    .select('version')
    .eq('prd_id', currentPrototype.prd_id)
    .order('version', { ascending: false })
    .limit(1)
    .single();

  const nextVersion = maxVersionData ? maxVersionData.version + 1 : 1;

  // Create new prototype version with 'generating' status
  const { data: newPrototype, error: createError } = await supabase
    .from('prototypes')
    .insert({
      prd_id: currentPrototype.prd_id,
      idea_id: currentPrototype.idea_id,
      user_id: user.id,
      status: 'generating',
      version: nextVersion,
      refinement_prompt: body.refinementPrompt,
    })
    .select()
    .single();

  if (createError) {
    console.error('Failed to create refinement version:', createError);
    return new Response(
      JSON.stringify({ 
        error: 'Failed to create refinement version', 
        code: 'DB_ERROR' 
      } as ErrorResponse),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Start refinement generation in background
  refinePrototypeAsync(
    supabase,
    newPrototype.id,
    currentPrototype.prd_documents.content,
    currentPrototype.code,
    body.refinementPrompt
  );

  const response: RefineResponse = {
    newPrototypeId: newPrototype.id,
    status: 'generating',
    version: nextVersion,
  };

  return new Response(
    JSON.stringify(response),
    { status: 202, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
  );
}

/**
 * Background refinement task
 */
async function refinePrototypeAsync(
  supabase: any,
  prototypeId: string,
  prdContent: any,
  currentCode: string,
  refinementPrompt: string
) {
  try {
    const prompt = buildRefinementPrompt(prdContent, currentCode, refinementPrompt);

    // Generate with retry logic
    const result = await withRetry(() => 
      generateWithOpenLovable(prompt, { isRefinement: true })
    );

    // Update prototype with success
    await supabase
      .from('prototypes')
      .update({
        code: result.code,
        url: result.url,
        status: 'ready',
      })
      .eq('id', prototypeId);

    console.log(`Prototype ${prototypeId} refined successfully`);

  } catch (error) {
    console.error(`Prototype ${prototypeId} refinement failed:`, error);

    // Update prototype with failure
    await supabase
      .from('prototypes')
      .update({
        status: 'failed',
      })
      .eq('id', prototypeId);
  }
}

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      status: 200,
      headers: corsHeaders 
    });
  }

  try {
    // Validate environment configuration
    if (!OPEN_LOVABLE_API_URL || !SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
      console.error('Missing required environment variables');
      return new Response(
        JSON.stringify({ error: 'Service not configured', code: 'CONFIG_ERROR' } as ErrorResponse),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify authentication
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Authentication required', code: 'AUTH_ERROR' } as ErrorResponse),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Initialize Supabase client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Verify user token
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication token', code: 'AUTH_ERROR' } as ErrorResponse),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Parse request body
    const body = await req.json();

    // Check if this is a restoration request
    if (body.restoreFromId) {
      return handleRestoration(supabase, user, body as RestoreRequest);
    }

    // Check if this is a refinement request
    if (body.prototypeId && body.refinementPrompt) {
      return handleRefinement(supabase, user, body as RefineRequest);
    }

    // Otherwise, handle as initial generation request
    const generateBody = body as GenerateRequest;

    if (!generateBody.prdId || !generateBody.ideaId || !generateBody.prdContent) {
      return new Response(
        JSON.stringify({
          error: 'Missing required fields: prdId, ideaId, prdContent',
          code: 'VALIDATION_ERROR',
        } as ErrorResponse),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Create prototype record with 'generating' status
    const { data: prototype, error: createError } = await supabase
      .from('prototypes')
      .insert({
        prd_id: generateBody.prdId,
        idea_id: generateBody.ideaId,
        user_id: user.id,
        status: 'generating',
        version: 1,
      })
      .select()
      .single();

    if (createError) {
      console.error('Failed to create prototype record:', createError);
      return new Response(
        JSON.stringify({ error: 'Failed to initialize prototype', code: 'DB_ERROR' } as ErrorResponse),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Return immediately with prototype ID for polling
    const response: GenerateResponse = {
      prototypeId: prototype.id,
      status: 'generating',
    };

    // Start generation in background (don't await)
    generatePrototypeAsync(supabase, prototype.id, generateBody.prdContent);

    return new Response(
      JSON.stringify(response),
      { status: 202, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Prototype generation failed:', error);

    return new Response(
      JSON.stringify({
        error: 'Failed to start prototype generation. Please try again.',
        code: 'GENERATION_FAILED',
      } as ErrorResponse),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

/**
 * Background generation task
 * Updates prototype record with results or error
 */
async function generatePrototypeAsync(
  supabase: any,
  prototypeId: string,
  prdContent: GenerateRequest['prdContent']
) {
  try {
    // Generate with retry logic
    const result = await withRetry(() => generateWithOpenLovable(prdContent));

    // Update prototype with success
    const { data: prototype, error: updateError } = await supabase
      .from('prototypes')
      .update({
        code: result.code,
        url: result.url,
        status: 'ready',
      })
      .eq('id', prototypeId)
      .select('idea_id')
      .single();

    if (updateError) {
      console.error(`Failed to update prototype ${prototypeId}:`, updateError);
      throw updateError;
    }

    // Update idea status to prototype_complete (Task 1 - AC 1, 4)
    if (prototype?.idea_id) {
      const { error: ideaUpdateError } = await supabase
        .from('ideas')
        .update({ status: 'prototype_complete' })
        .eq('id', prototype.idea_id);

      if (ideaUpdateError) {
        // Log error but don't fail the whole operation - prototype is already successful
        console.error(`Failed to update idea status for ${prototype.idea_id}:`, ideaUpdateError);
      } else {
        console.log(`Idea ${prototype.idea_id} status updated to prototype_complete`);
      }
    }

    console.log(`Prototype ${prototypeId} generated successfully`);
  } catch (error) {
    console.error(`Prototype ${prototypeId} generation failed:`, error);

    // Update prototype with failure
    // DO NOT update idea status on failure - keep it at prd_development for retry (Task 6 - AC 6)
    await supabase
      .from('prototypes')
      .update({
        status: 'failed',
      })
      .eq('id', prototypeId);
  }
}
