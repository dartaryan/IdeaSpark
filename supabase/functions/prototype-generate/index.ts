import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

interface GenerateRequest {
  prdId: string;
  ideaId: string;
  prdContent: {
    problemStatement: string;
    goals: string;
    userStories: string;
    requirements: string;
    technicalConsiderations: string;
  };
}

interface GenerateResponse {
  prototypeId: string;
  status: 'generating' | 'ready' | 'failed';
  url?: string;
  code?: string;
}

interface ErrorResponse {
  error: string;
  code: string;
}

const OPEN_LOVABLE_API_URL = Deno.env.get('OPEN_LOVABLE_API_URL');
const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

const GENERATION_TIMEOUT_MS = 60000; // 60 seconds

/**
 * PassportCard theme configuration for prototype generation
 */
const PASSPORTCARD_THEME_PROMPT = `
Generate a React application with the exact PassportCard brand specifications:

BRAND IDENTITY:
- Primary color: #E10514 (PassportCard red)
- Secondary: #1a1a2e (dark navy)
- Background: #f8f9fa (light gray)
- Success: #10b981, Warning: #f59e0b, Error: #ef4444

TYPOGRAPHY:
- Headings: Montserrat, font-weight 600-700
- Body text: Rubik, font-weight 400
- Include Google Fonts import

STYLING:
- CSS Framework: Tailwind CSS with DaisyUI
- Border radius: 20px (rounded-box)
- Card padding: 24px
- Modern, professional appearance

RESPONSIVE:
- Mobile-first design
- Proper breakpoints (sm, md, lg)
- Touch-friendly interactions

OUTPUT:
- Complete, self-contained React component
- Inline styles or Tailwind classes
- No external dependencies except React
- Include all necessary imports
`;

/**
 * Retry wrapper with exponential backoff
 */
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      console.error(`Attempt ${attempt + 1} failed:`, error);

      if (attempt < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}

/**
 * Call Open-Lovable API with timeout
 */
async function generateWithOpenLovable(
  prdContent: GenerateRequest['prdContent']
): Promise<{ code: string; url: string }> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), GENERATION_TIMEOUT_MS);

  try {
    const prompt = buildGenerationPrompt(prdContent);

    const response = await fetch(`${OPEN_LOVABLE_API_URL}/api/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${GEMINI_API_KEY}`, // Open-Lovable uses Gemini
      },
      body: JSON.stringify({
        prompt,
        config: {
          framework: 'react',
          styling: 'tailwindcss',
          includeTypes: true,
        },
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Open-Lovable API error:', response.status, errorText);
      throw new Error(`Open-Lovable API error: ${response.status}`);
    }

    const data = await response.json();

    if (!data.code) {
      throw new Error('No code generated by Open-Lovable');
    }

    return {
      code: data.code,
      url: data.url || null,
    };
  } catch (error) {
    clearTimeout(timeoutId);

    if (error.name === 'AbortError') {
      throw new Error('Prototype generation timed out after 60 seconds');
    }

    throw error;
  }
}

/**
 * Build generation prompt from PRD content
 */
function buildGenerationPrompt(prdContent: GenerateRequest['prdContent']): string {
  return `
${PASSPORTCARD_THEME_PROMPT}

Create a React prototype based on this Product Requirements Document:

## Problem Statement
${prdContent.problemStatement}

## Goals
${prdContent.goals}

## User Stories
${prdContent.userStories}

## Requirements
${prdContent.requirements}

## Technical Considerations
${prdContent.technicalConsiderations}

Generate a fully functional React prototype that:
1. Addresses the problem statement visually
2. Implements key user stories as interactive UI
3. Uses PassportCard branding throughout
4. Is responsive and professional
5. Includes realistic placeholder content

Return the complete React code ready to render.
`;
}

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      status: 200,
      headers: corsHeaders 
    });
  }

  try {
    // Validate environment configuration
    if (!OPEN_LOVABLE_API_URL || !SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
      console.error('Missing required environment variables');
      return new Response(
        JSON.stringify({ error: 'Service not configured', code: 'CONFIG_ERROR' } as ErrorResponse),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify authentication
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Authentication required', code: 'AUTH_ERROR' } as ErrorResponse),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Initialize Supabase client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Verify user token
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication token', code: 'AUTH_ERROR' } as ErrorResponse),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Parse and validate request
    const body: GenerateRequest = await req.json();

    if (!body.prdId || !body.ideaId || !body.prdContent) {
      return new Response(
        JSON.stringify({
          error: 'Missing required fields: prdId, ideaId, prdContent',
          code: 'VALIDATION_ERROR',
        } as ErrorResponse),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Create prototype record with 'generating' status
    const { data: prototype, error: createError } = await supabase
      .from('prototypes')
      .insert({
        prd_id: body.prdId,
        idea_id: body.ideaId,
        user_id: user.id,
        status: 'generating',
        version: 1,
      })
      .select()
      .single();

    if (createError) {
      console.error('Failed to create prototype record:', createError);
      return new Response(
        JSON.stringify({ error: 'Failed to initialize prototype', code: 'DB_ERROR' } as ErrorResponse),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Return immediately with prototype ID for polling
    const response: GenerateResponse = {
      prototypeId: prototype.id,
      status: 'generating',
    };

    // Start generation in background (don't await)
    generatePrototypeAsync(supabase, prototype.id, body.prdContent);

    return new Response(
      JSON.stringify(response),
      { status: 202, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Prototype generation failed:', error);

    return new Response(
      JSON.stringify({
        error: 'Failed to start prototype generation. Please try again.',
        code: 'GENERATION_FAILED',
      } as ErrorResponse),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

/**
 * Background generation task
 * Updates prototype record with results or error
 */
async function generatePrototypeAsync(
  supabase: any,
  prototypeId: string,
  prdContent: GenerateRequest['prdContent']
) {
  try {
    // Generate with retry logic
    const result = await withRetry(() => generateWithOpenLovable(prdContent));

    // Update prototype with success
    await supabase
      .from('prototypes')
      .update({
        code: result.code,
        url: result.url,
        status: 'ready',
      })
      .eq('id', prototypeId);

    console.log(`Prototype ${prototypeId} generated successfully`);
  } catch (error) {
    console.error(`Prototype ${prototypeId} generation failed:`, error);

    // Update prototype with failure
    await supabase
      .from('prototypes')
      .update({
        status: 'failed',
      })
      .eq('id', prototypeId);
  }
}
